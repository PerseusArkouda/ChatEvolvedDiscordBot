"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isotropicError = _interopRequireDefault(require("isotropic-error"));

var _isotropicLater = _interopRequireDefault(require("isotropic-later"));

var _isotropicMake = _interopRequireDefault(require("isotropic-make"));

var _mersenneTwister = _interopRequireDefault(require("@dsibilly/mersenne-twister"));

var _net = _interopRequireDefault(require("net"));

var _PacketType = _interopRequireDefault(require("./PacketType"));

var _pino = _interopRequireDefault(require("pino"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var SourceRCONClient = (0, _isotropicMake["default"])({
  connect: function connect() {
    var _this = this;

    return new Promise(function (resolve, reject) {
      if (_this.hasAuthed) {
        reject(new _isotropicError["default"]({
          message: 'authentication has already occurred'
        }));
        return;
      }

      _this._tcpSocket = _net["default"].createConnection(_this.port, _this.host);

      _this._tcpSocket.on('connect', function () {
        _this.isReady = true;

        _this._log.info("Connected to ".concat(_this.host, ":").concat(_this.port));

        _this.send(_this.password, _PacketType["default"].SERVERDATA_AUTH).then(function () {
          _this.hasAuthed = true;

          _this._log.info('Authentication successful');

          resolve();
        })["catch"](function (error) {
          reject(new _isotropicError["default"]({
            error: error,
            message: 'authentication failure'
          }));
        });
      });

      _this._tcpSocket.on('data', _this._handleResponse.bind(_this));

      _this._tcpSocket.on('error', function (error) {
        reject(new _isotropicError["default"]({
          error: error,
          message: "".concat(error.message)
        }));
      });

      _this._tcpSocket.on('end', function () {
        _this._reset();
      });
    });
  },
  disconnect: function disconnect() {
    var _this2 = this;

    return new Promise(function (resolve, reject) {
      if (!_this2._tcpSocket) {
        reject(new _isotropicError["default"]({
          message: 'adapter is already disconnected'
        }));
        return;
      }

      if (!_this2.hasAuthed) {
        reject(new _isotropicError["default"]({
          message: 'this connection is not authenticated'
        }));
        return;
      }

      _this2._tcpSocket.once('error', function (error) {
        reject(new _isotropicError["default"]({
          error: error,
          message: 'TCP socket disconnect error'
        }));
      });

      _this2._tcpSocket.unref();

      _this2._tcpSocket.end(null, function () {
        _this2._reset();

        _this2._log.info('Disconnect successful');

        resolve();
      });
    });
  },
  send: function send(command, packetType) {
    var _this3 = this;

    packetType = packetType || _PacketType["default"].SERVERDATA_EXECCOMMAND;
    return new Promise(function (resolve, reject) {
      if (!_this3.isReady) {
        // The socket isn't ready yet...
        throw new _isotropicError["default"]({
          message: 'TCP socket is not ready yet'
        });
      }

      if (!_this3.hasAuthed && packetType !== _PacketType["default"].SERVERDATA_AUTH) {
        throw new _isotropicError["default"]({
          message: 'this connection is not authenticated'
        });
      }

      var length = Buffer.byteLength(command),
          id = Math.trunc(_this3._rng.random() * (0x98967F - 0xF4240) + 0xF4240);
      var buffer, requestTimeout;

      if (packetType === _PacketType["default"].SERVERDATA_AUTH) {
        _this3._authPacketId = id;
      }

      buffer = Buffer.allocUnsafe(length + 14);
      buffer.writeInt32LE(length + 10, 0);
      buffer.writeInt32LE(id, 4);
      buffer.writeInt32LE(packetType, 8);
      buffer.write(command, 12);
      buffer.fill(0x00, length + 12);

      _this3._log.info("Sending command '".concat(command, "'"));

      _this3._tcpSocket.write(buffer.toString('binary'), 'binary');

      requestTimeout = (0, _isotropicLater["default"])(_this3.timeout, function () {
        _this3._timedOutRequests.push(id);

        _this3._callbacks["delete"](id);

        if (packetType === _PacketType["default"].SERVERDATA_AUTH) {
          _this3._authPacketId = null;
        }

        return reject(new _isotropicError["default"]({
          message: 'request timeout'
        }));
      });

      _this3._callbacks.set(id, function (data, error) {
        requestTimeout.cancel();

        _this3._callbacks["delete"](id);

        if (packetType === _PacketType["default"].SERVERDATA_AUTH) {
          _this3._authPacketId = null;
        }

        if (error) {
          reject(new _isotropicError["default"]({
            error: error,
            message: 'response callback error'
          }));
          return;
        }

        _this3._log.info({
          commandId: id,
          data: data
        });

        resolve(data);
      });
    });
  },
  _handleResponse: function _handleResponse(data) {
    var length = data.readInt32LE(0),
        id = data.readInt32LE(4),
        type = data.readInt32LE(8);
    var dataString;

    if (!length) {
      throw new _isotropicError["default"]({
        message: 'received empty response packet'
      });
    }

    if (this._timedOutRequests.includes(id)) {
      this._timedOutRequests.splice(this._timedOutRequests.indexOf(id), 1);

      return;
    }

    if (type === _PacketType["default"].SERVERDATA_AUTH_RESPONSE && id === -1) {
      this._callbacks.get(this._authPacketId)(null, new _isotropicError["default"]({
        message: 'authentication failure'
      }));
    } else if (this._callbacks.has(id)) {
      dataString = data.toString('ascii', 12, length + 2);

      if (dataString.charAt(dataString.length - 1) === '\n') {
        dataString = dataString.substring(0, dataString.length - 1);
      }

      this._callbacks.get(id)(dataString);
    } else if (id === 0 && type === _PacketType["default"].SERVERDATA_RESPONSE_VALUE) {
      this._log.info({
        id: id,
        length: length,
        payload: data.toString('ascii', 12, length + 2)
      }, 'Suspected keep-alive packet');
    } else {
      this._log.warn({
        id: id,
        length: length,
        type: type
      }, "Response id ".concat(id, " did not match any known request id"));
    }
  },
  _init: function _init(host, port, password, timeout) {
    var logEnabled = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    if (!host || !host.trim()) {
      throw new _isotropicError["default"]({
        message: 'host argument must not be empty'
      });
    }

    if (typeof port === 'string') {
      var _ref = [null, port, password];
      port = _ref[0];
      password = _ref[1];
      timeout = _ref[2];
    }

    if (!password || !password.trim()) {
      throw new _isotropicError["default"]({
        message: 'password argument must not be empty'
      });
    }

    this.hasAuthed = false;
    this.host = host;
    this.isReady = false;
    this.password = password;
    this.port = port || 27015;
    this.timeout = timeout || 5000;
    this._authPacketId = null;
    this._callbacks = new Map();
    this._log = (0, _pino["default"])({
      enabled: logEnabled,
      name: 'source-rcon-client',
      prettyPrint: true
    });
    this._rng = new _mersenneTwister["default"]();
    this._tcpSocket = null;
    this._timedOutRequests = [];
    return this;
  },
  _reset: function _reset() {
    var _this4 = this;

    return new Promise(function (resolve) {
      _this4.hasAuthed = false;
      _this4.isReady = false;
      _this4._tcpSocket = null;

      _this4._callbacks.clear();

      resolve();
    });
  }
});
var _default = SourceRCONClient;
exports["default"] = _default;